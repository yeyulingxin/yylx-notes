## redis为什么快

1. 完全基于内存，没有磁盘开销（持久化除外，这个单独算）
2. 单线程执行，避免多个线程上下文切换的性能损耗（为什么用单线程）
3. IO多路复用，通过epoll的方式提升效率（wait，poll，epoll的区别）
4. 底层的存储优化，原生数据结构，提升性能

## 为什么采用单线程

CPU不会成为Redis的制约瓶颈，redis主要受内存、网络限制；

linux上使用pipelining可以每秒传递100w个请求，如果应用程序主要使用O(N) 或 O(log(N))命令，则几乎不会使用太多CPU，属于IO密集型系统；

## Redis 6.0后改为多线程是改的什么

redis的多线程主要是用于处理数据的读写、协议解析；执行命令还是采用单线程顺序执行；

之所以引入多线程主要是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程进行一些周边预处理，提升IO的读写效率，从而提高了整体的吞吐量。

redis6引入的多线程IO对性能提升至少一倍以上。

## redis的性能

读 10w次/s
写 8w次/s

## 特性

1. 高性能；
2. 数据持久化，支持RDB、AOF；
3. 支持事务，通过MULTI和EXEC指令包起来；
4. 多种数据结果；
5. 主从复制
6. 发布订阅、通知、key过期等；

## 数据机构

### String

底层数据类型： int整数、embstr简单动态字符串、raw简单动态字符串
没有使用C语言的传统字符串，而是自己实现的一个简单动态 字符串SDS的抽象类型，并保存了长度信息；

### Hash

底层数据结构 hashtable、ziplist

### List

底层数据类型：linkedlist、ziplist

### Set

底层数据类型：intset、hashtable

### SortedSet

底层数据类型：skiplist、ziplist

### Bitmap

底层是String数据类型

### HyperLogLog

底层是String数据类型

### Geospatial

底层是SortedSet数据类型

## 底层数据结构说明

字符串。没有采用C语言的传统字符串，而是自己实现的一个简单动态字符串SDS的抽象类型，并保存了长度信息。
链表（linkedlist）。双向无环链表结构，每个链表的节点由一个listNode结构来表示，每个节点都有前置和后置节点的指针
字典（hashtable）。保存键值对的抽象数据结构，底层使用hash表，每个字典带有两个hash表，供平时使用和rehash时使用。
跳跃表（skiplist）。跳跃表是有序集合的底层实现之一。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表 信息(
表头、表尾节点、⻓度等)，zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-
32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。
整数集合（intset）。用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。
压缩列表（ziplist）。为节约内存而开发的顺序性数据结构，可以包含多个节点，每个节点可以保存一个字节数组或者整数值。

## 应用场景

### String

缓存
计数器
分布式锁

### List

链表
队列
微博关注人时间轴列表

### Hash

用户信息
Hash表

### Set

去重
赞
踩
共同好友

### Zset

访问量排行榜
点击量排行榜

## 过期key的删除策略

3种

### 惰性删除

使用key时才进行检查，如果已经过期，则删除
缺点：过期的key如果没有被访问到，一直无法删除，一直占用内存，造成空间浪费

### 定期删除

每隔一段时间做一次检查，删除过期的key，每次只是随机去一些key去检查；
处理过程：
1. 从过期字段中随机抽取20个key；
2. 检查这20个key是否过期，并删除已经过期的key；
3. 如果过期key的占比超过25%，也就是超过5个；则继续重复步骤1；如果已过期的比例小于25%，则停止本次任务；然后等待下一轮再检查；
定期删除是一个无限循环过程，为了避免循环过期，导致线程卡死，redis增加了定期删除循环流程的时间上限，默认不会超过25ms；
Redis的定期删除默认是每隔100ms执行一次，可以通过修改配置文件中的hz参数调整

### 定时删除

为每个key设置过期时间，同时创建一个定时器；一旦到期，立即执行删除；
缺点：如果过期key比较多时，占用CPU较多 ，对服务的性能有很大影响

原理是在设置键的同时，将键的过期时间记录在一个有序集合中；有序集合的成员为键的过期时间戳，分值为键的名字；通过定时器，refis可以定期遍历有序集合，找到过期的键并删除；

## 内存淘汰策略

当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证Redis 服务器的正常运行。

1. 不进行数据淘汰
   noeviction（Redis3.0之后，默认的内存淘汰策略）：禁止淘汰数据。当内存达到阈值的时候，新写入操作报错

2. 对设置了过期时间的数据进行淘汰
   volatile-random：随机淘汰设置了过期时间的任意键值；
   volatile-ttl：从已设置过期时间的key中，移出即将要过期的key
   volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：所有设置过期时间的键值中，最久未使用的键值；
   volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：所有设置过期时间的键值中，最少使用的键值；

3. 所有数据范围内淘汰
   allkeys-random：随机淘汰任意键值;
   allkeys-lru：淘汰整个键值中最久未使用的键值；
   allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

内存淘汰策略可以通过配置文件来修改，Redis.conf 对应的配置项是 maxmemory-policy 修改对应的值就行，默认是 no-eviction

## redis挂了怎么办

1. 哨兵和集群方案，主备进行切换；
2. 增加前置缓存（本地缓存）（可以通过开关切换，避免redis突然挂掉，高并发请求将数据库打挂）;

## redis持久化机制

1. RDB - 快照
   将某个时间点上的数据库状态保存在RDB文件中，RDB文件是一个压缩的二进制文件，保存在磁盘上，当redis崩溃时，可用于恢复数据。通过save、bgsave命令触发；

   save：会阻塞redis进程，直到RDB文件创建完毕，在进程阻塞期间，redis不能处理任何命令请求。
   bgsave：会 fork 出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。

    * 优点：
      将某一时间点redis内的所有数据保存下来，当我们做「大型的数据恢复时，RDB的恢复速度会很快」
      由于RDB的FROK子进程这种机制，对客户端提供读写服务的影响会非常小
    * 缺点：
      「有可能会产生长时间的数据丢失」
      可能会有长时间停顿：我们前面讲了，fork 子进程这个过程是和 redis 的数据量有很大关系的，如果「数据量很大,那么很有可能会使redis暂停几秒

      举个例子假设我们定时5分钟备份一次，在10:00的时候 redis 备份了数据，但是如果在10:
      04的时候服务挂了，那么我们就会丢失在10:00到10:04的整个数据

   ### 什么时候会触发
       1、通过配置文件，设置一定时间后自动执行RDB
       2、如采用主从复制过程，会自动执行RDB
       3、Redis 执行shutdown时，在未开启AOF后会执行RDB


2. AOF - 追加文件
   以日志的形式记录每个写操作（非读操作）。当不同节点同步数据时，读取日志文件的内容将写指令从前到后执行一次，即可完成数据恢复。
   AOF 通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开AOF

   ### AOP持久化策略
   1、always：每执行一次数据修改命令就将其命令写入到磁盘日志文件上。
   2、everysec：每秒将命令写入到磁盘日志文件上。
   3、no：不主动设置，由操作系统决定什么时候写入到磁盘日志文件上。

    * 优点
      AOF可以「更好的保护数据不丢失」，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据
      AOF是将命令直接追加在文件末尾的，写入性能非常高
      AOF日志文件的命令通过非常可读的方式进行记录，这个非常「适合做灾难性的误删除紧急恢复」，如果某人不小心用 flushall
      命令清空了所有数据，只要这个时候还没有执行 rewrite，那么就可以将日志文件中的 flushall 删除，进行恢复

    * 缺点
      对于同一份数据源来说，一般情况下AOF 文件比 RDB 数据快照要大
      由于 .aof 的每次命令都会写入，那么相对于 RDB 来说「需要消耗的性能也就更多」，当然也会有 aof 重写将 aof 文件优化。
      数据恢复比较慢，不适合做冷备。

## 主从复制

### 主从复制流程

        1. slave启动后，向master发送sync命令；
        2. master收到sync之后，执行bgsave保存快照，生成RDB全量文件
        3. master把slave的写命令记录到缓存
        4. bgsave执行完毕之后，发送RDB文件到slave，slave执行
        5. master发送缓冲区的写命令给slave，slave接收命令并执行，完成复制初始化
        6. 此后，master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性

优点：
1. master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
2. master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
缺点：
1. 不具备自动容错与恢复功能，master 节点宕机后，需要手动指定新的 master
2. master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
3. 难以支持在线扩容，Redis 的容量受限于单机配置

## 哨兵模式

    哨兵模式基于主从复制模式，增加了哨兵来监控与自动处理故障。

优点：
1. 哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有
2. master 挂掉可以自动进行切换，系统可用性更高
缺点：
1. Redis 的容量受限于单机配置
2. 需要额外的资源来启动sentinel进程

### 哨兵的故障转移过程

    问题：
        1. 主库真的挂了吗？
        2. 应该选择哪一个从库切换为主库？
        3. 怎么把新主库的信息通知给从库和客户端呢？

#### 哨兵监控

    哨兵




